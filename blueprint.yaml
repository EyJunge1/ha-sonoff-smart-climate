blueprint:
  name: Sonoff Smart Climate Control
  description: >
    Intelligent control of Sonoff thermostats with external temperature sensors.
    
    **Features:**
    - Automatic detection of all required entities
    - Simple configuration: Just select thermostats and sensors
    - Control single or multiple thermostats
    - One or multiple temperature sensors (average calculated for multiple sensors)
    - Automatic fallback to internal sensor if external sensors become unavailable
    - Automatic synchronization of target temperatures for multiple thermostats
    - Optional: Window detection for automatic heating control
    - Configurable temperature limits and rounding precision
    - Robust error handling for all edge cases (see EDGE_CASES.md)
    
    Flexible for single rooms or large zones with multiple radiators.
  domain: automation
  author: EyJunge1
  source_url: https://github.com/eyjunge1/ha-sonoff-smart-climate/blob/main/blueprint.yml
  homeassistant:
    min_version: 2024.6.0
  
  input:
    # ==================== THERMOSTAT ====================
    thermostat_section:
      name: Thermostat Configuration
      icon: mdi:thermostat
      description: >
        Select one or multiple thermostats and the associated sensors.
        For multiple thermostats: All use the same external temperature sensor, and 
        when you adjust any thermostat, all others automatically match its temperature.
        Simply turn the dial on any thermostat and all others follow!
      input:
        thermostats:
          name: Thermostat(s)
          description: >
            One or multiple Sonoff thermostats.
            For multiple thermostats: When you change the temperature on any thermostat 
            (by turning the dial), all others will automatically follow. This prevents 
            conflicts where thermostats work against each other.
          selector:
            entity:
              multiple: true
              filter:
                - domain: climate
        
        temp_sensors:
          name: Temperature Sensor(s)
          description: >
            One or multiple external temperature sensors (e.g. Aqara, Zigbee).
            For multiple sensors, the average temperature will be calculated.
          selector:
            entity:
              multiple: true
              filter:
                - domain: sensor
                  device_class: temperature
    
    # ==================== SETTINGS ====================
    settings_section:
      name: Settings
      icon: mdi:cog
      description: Configure the behavior of synchronization
      collapsed: true
      input:
        temp_min:
          name: Minimum Temperature
          description: Temperature values below this value will be ignored as invalid
          default: 0
          selector:
            number:
              min: -10
              max: 15
              step: 1
              unit_of_measurement: °C
        
        temp_max:
          name: Maximum Temperature
          description: Temperature values above this value will be ignored as invalid
          default: 50
          selector:
            number:
              min: 30
              max: 60
              step: 1
              unit_of_measurement: °C
        
        round_precision:
          name: Rounding Precision
          description: How many decimal places to round to
          default: 1
          selector:
            number:
              min: 0
              max: 2
              step: 1
        
        sync_target_temperature:
          name: Synchronize Target Temperature
          description: >
            When multiple thermostats are used, automatically synchronize their target temperatures 
            to avoid conflicts. When you change the temperature on any thermostat (by turning the dial),
            all other thermostats will automatically be set to the same temperature. This ensures all 
            radiators work together instead of against each other.
          default: true
          selector:
            boolean:
    
    # ==================== WINDOW DETECTION (Optional) ====================
    window_section:
      name: Window Detection (Optional)
      icon: mdi:window-open
      description: >
        Automatic heating control with open windows. Reacts instantly when 
        any window/door opens or closes. For multiple thermostats, all will be notified.
      collapsed: true
      input:
        enable_window_detection:
          name: Enable Window Detection
          description: Enable automatic detection of open windows
          default: false
          selector:
            boolean:
        
        window_sensors:
          name: Window Contacts
          description: >
            Select all window and door contacts for this room.
            As soon as one of them opens or closes, ALL thermostats immediately react 
            and switch to "Open Window" mode. Works instantly, no delay!
          default: []
          selector:
            entity:
              multiple: true
              filter:
                - domain: binary_sensor
                  device_class:
                    - window
                    - door
                    - opening

variables:
  # User inputs
  thermostats: !input thermostats
  temp_sensors: !input temp_sensors
  temp_min: !input temp_min
  temp_max: !input temp_max
  round_precision: !input round_precision
  sync_target_temp: !input sync_target_temperature
  enable_window: !input enable_window_detection
  window_sensors: !input window_sensors
  
  # Convert to lists (handle single or multiple entities)
  thermostat_list: >
    {{ [thermostats] if thermostats is string else (thermostats if thermostats else []) }}
  
  sensor_list: >
    {{ [temp_sensors] if temp_sensors is string else (temp_sensors if temp_sensors else []) }}
  
  # Validate and correct min/max temperature limits (automatic error correction)
  # Edge Case: Falsche Min/Max-Temperaturgrenzen
  temp_min_valid: >
    {{ temp_min if temp_min < temp_max else temp_max - 1 }}
  
  temp_max_valid: >
    {{ temp_max if temp_max > temp_min else temp_min + 1 }}
  
  # Auto-detect: All required entities in ONE optimized loop
  # Edge Case: Thermostat kommt wieder online - Entities werden bei jedem Trigger neu erkannt
  detected_entities: >
    {% set ns = namespace(inputs=[], selects=[], switches=[]) %}
    {% for thermostat in thermostat_list %}
      {% set device_id = device_id(thermostat) %}
      {% if device_id %}
        {% for entity in device_entities(device_id) %}
          {% if 'external_temperature_input' in entity and not ('_2' in entity or '_3' in entity) %}
            {% set ns.inputs = ns.inputs + [entity] %}
          {% elif 'temperature_sensor' in entity and states[entity].domain == 'select' %}
            {% set ns.selects = ns.selects + [entity] %}
          {% elif 'open_window' in entity and states[entity].domain == 'switch' %}
            {% set ns.switches = ns.switches + [entity] %}
          {% endif %}
        {% endfor %}
      {% endif %}
    {% endfor %}
    {{ {'inputs': ns.inputs, 'selects': ns.selects, 'switches': ns.switches} }}
  
  # Extract entity lists from detection result
  temp_input_list: "{{ detected_entities.inputs }}"
  temp_sensor_select_list: "{{ detected_entities.selects }}"
  window_switch_list: "{{ detected_entities.switches }}"

triggers:
  # Regular interval: Update external temperature every 30 seconds
  # Edge Case: Sensor kommt wieder online - Wird alle 30s automatisch geprüft
  # Edge Case: Alle externen Sensoren werden unavailable - System prüft alle 30s auf Recovery
  - trigger: time_pattern
    seconds: "/30"
  
  # Initialize on Home Assistant startup
  # Edge Case: Home Assistant Neustart - Automatische Initialisierung beim Start
  - trigger: homeassistant
    event: start
  
  # Instant reaction: Temperature sensor changed
  # Edge Case: Sensor mit zu hoher Update-Frequenz - Restart mode bricht vorherige Ausführung ab
  - trigger: state
    entity_id: !input temp_sensors
  
  # Instant reaction: Thermostat target temperature changed (dial turned)
  # Edge Case: Mehrere Thermostate ändern gleichzeitig - Restart mode, letzte Änderung gewinnt
  - trigger: state
    entity_id: !input thermostats
    attribute: temperature
  
  # Instant reaction: Thermostat state changed (e.g. comes back online)
  # Edge Case: Thermostat kommt wieder online - Sofortige Erkennung und Rekonfiguration
  - trigger: state
    entity_id: !input thermostats
  
  # Instant reaction: Window/door opened or closed
  # Edge Case: Fenster wird während Heizvorgang geöffnet - Sofortige Reaktion
  # Edge Case: Fensterkontakt ändert State zu oft - Restart mode verarbeitet letzte Änderung
  - trigger: state
    entity_id: !input window_sensors

condition:
  # Early validation: Skip if no thermostats configured
  # Edge Case: Keine Thermostate konfiguriert - Automatisierung läuft nicht, aber fehlerfrei
  - condition: template
    value_template: "{{ thermostat_list | length > 0 }}"

actions:
  # ==================== STEP 1: WINDOW DETECTION (PRIORITY - RUNS FIRST) ====================
  # Edge Case: Fenster wird während Heizvorgang geöffnet - Sofortige Reaktion durch restart mode
  # Edge Case: Fensterkontakt wird unavailable/unknown - Wird automatisch ignoriert
  # Edge Case: Window Detection Trigger bei Thermostat-Änderung - Conditions verhindern falsche Ausführung
  - choose:
      - conditions:
          - condition: template
            value_template: >
              {{ enable_window and 
                 window_switch_list | length > 0 and 
                 window_sensors | length > 0 and
                 trigger.platform == 'state' and
                 trigger.entity_id is defined and
                 trigger.entity_id in window_sensors }}
        sequence:
          - variables:
              # Check if ANY window/door is currently open (unavailable sensors are ignored)
              # Edge Case: expand() schlägt fehl mit ungültiger Entity - expand() überspringt automatisch
              any_window_open: >
                {{ expand(window_sensors) 
                   | rejectattr('state', 'in', ['unavailable', 'unknown', 'none', ''])
                   | selectattr('state', 'in', ['on', 'open']) 
                   | list | count > 0 }}
          
          # Set "Open Window" mode on ALL thermostats
          # Edge Case: Thermostat-Entities werden unavailable - Werden übersprungen
          - repeat:
              for_each: "{{ window_switch_list }}"
              sequence:
                - condition: template
                  value_template: >
                    {{ states(repeat.item) not in ['unavailable', 'unknown', 'none', ''] }}
                - action: "switch.turn_{{ 'on' if any_window_open else 'off' }}"
                  target:
                    entity_id: "{{ repeat.item }}"
          
          # Stop here - window trigger handled
          - stop: "Window state changed - heating control updated"
  
  # ==================== STEP 2: CALCULATE AVERAGE TEMPERATURE ====================
  # Edge Case: Einzelner Sensor wird unavailable/unknown - Wird automatisch ignoriert
  # Edge Case: Alle externen Sensoren werden unavailable - Triggers Fallback auf internal sensor
  # Edge Case: Sensor meldet ungültige Temperaturwerte - Gefiltert durch Min/Max-Grenzen
  # Edge Case: Sensor-State ist None oder leerer String - Wird ignoriert
  # Edge Case: Sensor meldet nicht-numerischen Wert - float(-999) Fallback
  - variables:
      # Collect valid temperature values (robust error handling)
      valid_temps: >
        {% set ns = namespace(temps=[]) %}
        {% if sensor_list | length > 0 %}
          {% for sensor in sensor_list %}
            {% set temp_state = states(sensor) %}
            {% if temp_state not in ['unavailable', 'unknown', 'none', ''] %}
              {% set temp = temp_state | float(-999) %}
              {% if temp > -999 and temp >= temp_min_valid and temp <= temp_max_valid %}
                {% set ns.temps = ns.temps + [temp] %}
              {% endif %}
            {% endif %}
          {% endfor %}
        {% endif %}
        {{ ns.temps }}
      
      # Calculate average temperature from all valid sensors
      # Edge Case: Sensor aktualisiert sehr langsam - Letzter Wert bleibt gültig
      avg_temp: >
        {% if valid_temps | length > 0 %}
          {{ (valid_temps | sum / valid_temps | length) | round(round_precision) }}
        {% else %}
          {{ 0 }}
        {% endif %}
      
      # Check if we have valid external sensor data
      has_valid_sensors: >
        {{ valid_temps | length > 0 and
           temp_input_list | length > 0 and
           temp_sensor_select_list | length > 0 }}
  
  # ==================== STEP 3: CONFIGURE THERMOSTAT SENSOR MODE ====================
  # Edge Case: Alle externen Sensoren werden unavailable - Automatischer Fallback auf internal sensor
  # Edge Case: Sensor kommt wieder online - Automatische Umschaltung zurück auf external sensor
  # Edge Case: Thermostat geht offline/unavailable - Wird automatisch übersprungen
  # Edge Case: Service Calls schlagen fehl - Home Assistant behandelt Fehler, Automatisierung läuft weiter
  - choose:
      # Case 1: Valid external sensors available → Use external sensor
      - conditions:
          - condition: template
            value_template: "{{ has_valid_sensors }}"
        sequence:
          # Configure thermostats to use external sensor
          - repeat:
              for_each: "{{ temp_sensor_select_list }}"
              sequence:
                - condition: template
                  value_template: >
                    {{ states(repeat.item) not in ['unavailable', 'unknown', 'none', ''] }}
                - action: select.select_option
                  target:
                    entity_id: "{{ repeat.item }}"
                  data:
                    option: "external"
          
          # Send average temperature to all thermostats
          - repeat:
              for_each: "{{ temp_input_list }}"
              sequence:
                - condition: template
                  value_template: >
                    {{ states(repeat.item) not in ['unavailable', 'unknown', 'none', ''] }}
                - action: number.set_value
                  target:
                    entity_id: "{{ repeat.item }}"
                  data:
                    value: "{{ avg_temp }}"
      
      # Case 2: No valid external sensors → Fallback to internal sensor
      - conditions:
          - condition: template
            value_template: >
              {{ not has_valid_sensors and
                 temp_sensor_select_list | length > 0 }}
        sequence:
          # Configure thermostats to use internal sensor (fallback)
          - repeat:
              for_each: "{{ temp_sensor_select_list }}"
              sequence:
                - condition: template
                  value_template: >
                    {{ states(repeat.item) not in ['unavailable', 'unknown', 'none', ''] }}
                - action: select.select_option
                  target:
                    entity_id: "{{ repeat.item }}"
                  data:
                    option: "internal"
  
  # ==================== STEP 4: SYNCHRONIZE TARGET TEMPERATURES (MULTI-THERMOSTAT) ====================
  # Edge Case: Thermostat-Synchronisierung in Endlosschleife - Verhindert durch Smart Change Detection
  # Edge Case: Zwei Thermostate mit identischer Zieltemperatur - Keine unnötigen Service Calls
  # Edge Case: Mehrere Thermostate ändern gleichzeitig - Restart mode, letzte Änderung gewinnt
  # Edge Case: Thermostat hat ungültige Zieltemperatur - Wird gefiltert
  # Edge Case: Synchronisierung mit offline Thermostat - Wird übersprungen
  - condition: template
    value_template: >
      {{ sync_target_temp and 
         thermostat_list | length > 1 and 
         trigger is defined and 
         trigger.entity_id is defined and
         trigger.entity_id in thermostat_list and
         trigger.to_state is defined and
         trigger.to_state.attributes.temperature is defined }}
  
  - variables:
      triggered_thermostat: "{{ trigger.entity_id }}"
      new_target_temp_raw: "{{ trigger.to_state.attributes.temperature | float(0) }}"
      # Validate target temperature: must be > 0 and within reasonable range (5-35°C)
      new_target_temp: >
        {% set temp = new_target_temp_raw %}
        {% if temp > 0 and temp >= 5 and temp <= 35 %}
          {{ temp }}
        {% else %}
          {{ 0 }}
        {% endif %}
  
  # Skip synchronization if temperature is invalid
  - condition: template
    value_template: "{{ new_target_temp | float(0) > 0 }}"
  
  # Apply new temperature to all OTHER thermostats (if different)
  # Smart Change Detection: Only update if temperature actually changed
  - repeat:
      for_each: "{{ thermostat_list }}"
      sequence:
        - condition: template
          value_template: >
            {{ states(repeat.item) not in ['unavailable', 'unknown', 'none', ''] }}
        
        - variables:
            current_temp: "{{ state_attr(repeat.item, 'temperature') | float(0) }}"
        
        # Skip if: same thermostat OR temperature already matches (prevents loops)
        - condition: template
          value_template: >
            {{ repeat.item != triggered_thermostat and
               current_temp != new_target_temp }}
        
        - action: climate.set_temperature
          target:
            entity_id: "{{ repeat.item }}"
          data:
            temperature: "{{ new_target_temp }}"

mode: restart
