blueprint:
  name: Sonoff Smart Climate Control
  description: >
    Intelligent control of Sonoff thermostats with external temperature sensors.
    
    **Features:**
    - Automatic detection of all required entities
    - Simple configuration: Just select thermostats and sensors
    - Control single or multiple thermostats
    - One or multiple temperature sensors (average calculated for multiple sensors)
    - Automatic fallback to internal sensor if external sensors become unavailable
    - Automatic synchronization of target temperatures for multiple thermostats
    - Optional: Window detection for automatic heating control
    - Configurable temperature limits and rounding precision
    
    Flexible for single rooms or large zones with multiple radiators.
  domain: automation
  author: EyJunge1
  source_url: https://github.com/eyjunge1/ha-sonoff-smart-climate/blob/main/blueprint.yml
  homeassistant:
    min_version: 2024.6.0
  
  input:
    # ==================== THERMOSTAT ====================
    thermostat_section:
      name: Thermostat Configuration
      icon: mdi:thermostat
      description: >
        Select one or multiple thermostats and the associated sensors.
        For multiple thermostats: All use the same external temperature sensor, and 
        when you adjust any thermostat, all others automatically match its temperature.
        Simply turn the dial on any thermostat and all others follow!
      input:
        thermostats:
          name: Thermostat(s)
          description: >
            One or multiple Sonoff thermostats.
            For multiple thermostats: When you change the temperature on any thermostat 
            (by turning the dial), all others will automatically follow. This prevents 
            conflicts where thermostats work against each other.
          selector:
            entity:
              multiple: true
              filter:
                - domain: climate
        
        temp_sensors:
          name: Temperature Sensor(s)
          description: >
            One or multiple external temperature sensors (e.g. Aqara, Zigbee).
            For multiple sensors, the average temperature will be calculated.
          selector:
            entity:
              multiple: true
              filter:
                - domain: sensor
                  device_class: temperature
    
    # ==================== SETTINGS ====================
    settings_section:
      name: Settings
      icon: mdi:cog
      description: Configure the behavior of synchronization
      collapsed: true
      input:
        temp_min:
          name: Minimum Temperature
          description: Temperature values below this value will be ignored as invalid
          default: 0
          selector:
            number:
              min: -10
              max: 15
              step: 1
              unit_of_measurement: °C
        
        temp_max:
          name: Maximum Temperature
          description: Temperature values above this value will be ignored as invalid
          default: 50
          selector:
            number:
              min: 30
              max: 60
              step: 1
              unit_of_measurement: °C
        
        round_precision:
          name: Rounding Precision
          description: How many decimal places to round to
          default: 1
          selector:
            number:
              min: 0
              max: 2
              step: 1
        
        sync_target_temperature:
          name: Synchronize Target Temperature
          description: >
            When multiple thermostats are used, automatically synchronize their target temperatures 
            to avoid conflicts. When you change the temperature on any thermostat (by turning the dial),
            all other thermostats will automatically be set to the same temperature. This ensures all 
            radiators work together instead of against each other.
          default: true
          selector:
            boolean:
    
    # ==================== WINDOW DETECTION (Optional) ====================
    window_section:
      name: Window Detection (Optional)
      icon: mdi:window-open
      description: >
        Automatic heating control with open windows. Reacts instantly when 
        any window/door opens or closes. For multiple thermostats, all will be notified.
      collapsed: true
      input:
        enable_window_detection:
          name: Enable Window Detection
          description: Enable automatic detection of open windows
          default: false
          selector:
            boolean:
        
        window_sensors:
          name: Window Contacts
          description: >
            Select all window and door contacts for this room.
            As soon as one of them opens or closes, ALL thermostats immediately react 
            and switch to "Open Window" mode. Works instantly, no delay!
          default: []
          selector:
            entity:
              multiple: true
              filter:
                - domain: binary_sensor
                  device_class:
                    - window
                    - door
                    - opening

variables:
  # User inputs
  thermostats: !input thermostats
  temp_sensors: !input temp_sensors
  temp_min: !input temp_min
  temp_max: !input temp_max
  round_precision: !input round_precision
  sync_target_temp: !input sync_target_temperature
  enable_window: !input enable_window_detection
  window_sensors: !input window_sensors
  
  # Convert to lists (handle single or multiple)
  thermostat_list: >
    {{ [thermostats] if thermostats is string else thermostats }}
  
  sensor_list: >
    {{ [temp_sensors] if temp_sensors is string else temp_sensors }}
  
  # Auto-detect: All required entities in ONE loop (performance optimization)
  detected_entities: >
    {% set ns = namespace(inputs=[], selects=[], switches=[]) %}
    {% for thermostat in thermostat_list %}
      {% set device_id = device_id(thermostat) %}
      {% if device_id %}
        {% for entity in device_entities(device_id) %}
          {% if 'external_temperature_input' in entity and not ('_2' in entity or '_3' in entity) %}
            {% set ns.inputs = ns.inputs + [entity] %}
          {% elif 'temperature_sensor' in entity and states[entity].domain == 'select' %}
            {% set ns.selects = ns.selects + [entity] %}
          {% elif 'open_window' in entity and states[entity].domain == 'switch' %}
            {% set ns.switches = ns.switches + [entity] %}
          {% endif %}
        {% endfor %}
      {% endif %}
    {% endfor %}
    {{ {'inputs': ns.inputs, 'selects': ns.selects, 'switches': ns.switches} }}
  
  # Extract individual lists from combined detection
  temp_input_list: "{{ detected_entities.inputs }}"
  temp_sensor_select_list: "{{ detected_entities.selects }}"
  window_switch_list: "{{ detected_entities.switches }}"

triggers:
  # Regular interval: Update external temperature every 30 seconds
  - trigger: time_pattern
    seconds: "/30"
  
  # Initialize on Home Assistant startup
  - trigger: homeassistant
    event: start
  
  # Instant reaction: Temperature sensor changed
  - trigger: state
    entity_id: !input temp_sensors
  
  # Instant reaction: Thermostat target temperature changed (dial turned)
  - trigger: state
    entity_id: !input thermostats
    attribute: temperature
  
  # Instant reaction: Window/door opened or closed
  - trigger: state
    entity_id: !input window_sensors

condition: []

actions:
  # ==================== STEP 1: WINDOW DETECTION (PRIORITY - RUNS FIRST) ====================
  # Reacts instantly when ANY window/door opens or closes
  - choose:
      - conditions:
          - condition: template
            value_template: >
              {{ enable_window and 
                 window_switch_list | length > 0 and 
                 window_sensors | length > 0 and
                 trigger.platform == 'state' and
                 trigger.entity_id is defined and
                 trigger.entity_id in window_sensors }}
        sequence:
          - variables:
              # Check if ANY window/door is currently open
              any_window_open: >
                {{ expand(window_sensors) 
                   | selectattr('state', 'in', ['on', 'open']) 
                   | list | count > 0 }}
          
          # Set "Open Window" mode on ALL thermostats
          # - If ANY window is open → Turn ON (heating stops)
          # - If ALL windows are closed → Turn OFF (heating resumes)
          - repeat:
              for_each: "{{ window_switch_list }}"
              sequence:
                - action: "switch.turn_{{ 'on' if any_window_open else 'off' }}"
                  target:
                    entity_id: "{{ repeat.item }}"
          
          # Stop here - window trigger handled, no need to continue
          - stop: "Window state changed - heating control updated"
  
  # ==================== STEP 2: CALCULATE AVERAGE TEMPERATURE ====================
  - variables:
      # Collect valid temperature values (exclude unavailable/unknown sensors)
      valid_temps: >
        {% set ns = namespace(temps=[]) %}
        {% for sensor in sensor_list %}
          {% set temp_state = states(sensor) %}
          {% if temp_state not in ['unavailable', 'unknown', 'none', ''] %}
            {% set temp = temp_state | float(-999) %}
            {% if temp > -999 and temp >= temp_min and temp <= temp_max %}
              {% set ns.temps = ns.temps + [temp] %}
            {% endif %}
          {% endif %}
        {% endfor %}
        {{ ns.temps }}
      
      # Calculate average temperature from all valid sensors
      avg_temp: >
        {% if valid_temps | length > 0 %}
          {{ (valid_temps | sum / valid_temps | length) | round(round_precision) }}
        {% else %}
          {{ 0 }}
        {% endif %}
      
      # Check if we have valid external sensor data
      has_valid_sensors: >
        {{ valid_temps | length > 0 and 
           avg_temp | float > 0 and
           temp_input_list | length > 0 and
           temp_sensor_select_list | length > 0 }}
  
  # ==================== STEP 3: CONFIGURE THERMOSTAT SENSOR MODE ====================
  # Choose between external (if sensors valid) or internal (if sensors unavailable)
  - choose:
      # Case 1: Valid external sensors available → Use external sensor
      - conditions:
          - condition: template
            value_template: "{{ has_valid_sensors }}"
        sequence:
          # Configure thermostats to use external sensor
          - repeat:
              for_each: "{{ temp_sensor_select_list }}"
              sequence:
                - action: select.select_option
                  target:
                    entity_id: "{{ repeat.item }}"
                  data:
                    option: "external"
          
          # Send average temperature to all thermostats
          - repeat:
              for_each: "{{ temp_input_list }}"
              sequence:
                - action: number.set_value
                  target:
                    entity_id: "{{ repeat.item }}"
                  data:
                    value: "{{ avg_temp }}"
      
      # Case 2: No valid external sensors → Fallback to internal sensor
      - conditions:
          - condition: template
            value_template: >
              {{ not has_valid_sensors and
                 temp_sensor_select_list | length > 0 }}
        sequence:
          # Configure thermostats to use internal sensor (fallback)
          - repeat:
              for_each: "{{ temp_sensor_select_list }}"
              sequence:
                - action: select.select_option
                  target:
                    entity_id: "{{ repeat.item }}"
                  data:
                    option: "internal"
  
  # ==================== STEP 5: SYNCHRONIZE TARGET TEMPERATURES (MULTI-THERMOSTAT) ====================
  # Only run if: sync enabled, multiple thermostats, trigger was a thermostat change, and valid temp
  - condition: template
    value_template: >
      {{ sync_target_temp and 
         thermostat_list | length > 1 and 
         trigger is defined and 
         trigger.entity_id is defined and
         trigger.entity_id in thermostat_list and
         trigger.to_state is defined and
         trigger.to_state.attributes.temperature is defined and
         trigger.to_state.attributes.temperature | float(0) > 0 }}
  
  - variables:
      triggered_thermostat: "{{ trigger.entity_id }}"
      new_target_temp: "{{ trigger.to_state.attributes.temperature | float(0) }}"
  
  # Apply new temperature to all OTHER thermostats (if different)
  - repeat:
      for_each: "{{ thermostat_list }}"
      sequence:
        - variables:
            current_temp: "{{ state_attr(repeat.item, 'temperature') | float(0) }}"
        
        # Skip if: same thermostat OR temperature already matches
        - condition: template
          value_template: >
            {{ repeat.item != triggered_thermostat and
               current_temp != new_target_temp }}
        
        - action: climate.set_temperature
          target:
            entity_id: "{{ repeat.item }}"
          data:
            temperature: "{{ new_target_temp }}"

mode: restart
